// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest
// DO NOT EDIT. ANY CHANGES WILL BE LOST

#include <ngrest/utils/Log.h>
#include <ngrest/utils/fromcstring.h>
#include <ngrest/utils/tostring.h>
#include <ngrest/utils/Exception.h>
#include <ngrest/common/ObjectModel.h>
#include <ngrest/common/ObjectModelUtils.h>
#include <ngrest/common/Message.h>
##ifneq($(interface.services.$count),0)
#include <ngrest/common/HttpMethod.h>
#include <ngrest/common/Service.h>
#include <ngrest/engine/ServiceDescription.h>
##endif
#include "$(interface.filePath)$(interface.name)Wrapper.h"
\
##var lastNs
##var lastNsEnd
\
##include <common/enums.cpp>
##include <common/typedefs.cpp>
##include <common/structs.cpp>

##ifneq($(interface.services.$count),0)
##foreach $(interface.services)

##include <common/nsopt.cpp>

$(service.name)Wrapper::$(service.name)Wrapper():
    service(new $(service.name)())
{
}

$(service.name)Wrapper::~$(service.name)Wrapper()
{
    delete service;
}


::ngrest::Service* $(service.name)Wrapper::getServiceImpl()
{
    return service;
}

void $(service.name)Wrapper::invoke(const ::ngrest::OperationDescription* operation, ::ngrest::MessageContext* context)
{
    \
##foreach $(service.operations)
if (operation->name == "$(operation.name)") {   //  **************** $(operation.name) *****************

        /// $(operation.return) $(operation.name)($(operation.params));

##ifeq($(operation.isAsynch),false)     //////////// synchronous ///////////////
\
##include <common/serviceRequest.cpp>
\
######### invoke the service synchronously ###########
##ifneq($(operation.return),void)
##ifeq($(operation.return.type),struct||typedef||template||string)
        const $(operation.return)& result = \
##else
        $(operation.return) result = \
##endif // const ref
##else  // void
        \
##endif
\
service->$(operation.name)(\
##var splitter
##foreach $(operation.params)
##ifeq($($splitter),)
##var splitter 1
##else
, \
##endif
##ifeq($(param.dataType.name),MessageContext)
*context\
##else
$(param.name)\
##endif
##endfor
);

##context $(operation.return)
##include <common/serviceResponse.cpp>
##endcontext
        context->callback->success();
\
\
##else                                  //////////// asynchronous ///////////////
\
##include <common/serviceRequest.cpp>

        class Callback_$(operation.name): public \
##ifeq($($callbackType),void)
VoidCallback
##else
::ngrest::Callback< $($callbackType) >
##endif
        {
        public:
            Callback_$(operation.name)(::ngrest::MessageContext* context_):
                context(context_)
            {
            }

            void success(\
##ifneq($($callbackType),void)
$($callbackType) result\
##endif
) override
            {
##foreach $(operation.params)
##ifeq($(param.dataType.name),Callback)
##indent +2
##context $(param.dataType.templateParams.templateParam1)
##include <common/serviceResponse.cpp>
##endcontext
##indent -2
##endif
##endfor
                context->callback->success();
                // no need to "delete this" - it's in mempool
            }

            virtual void error(const ::ngrest::Exception& error) override
            {
                context->callback->error(error);
                // no need to "delete this" - it's in mempool
            }

            ::ngrest::MessageContext* const context;
        };

        service->$(operation.name)(\
##var splitter
##foreach $(operation.params)
##ifeq($($splitter),)
##var splitter 1
##else
, \
##endif
##ifneq($(param.dataType.name),Callback)
$(param.name)\
##else
*context->pool->alloc<Callback_$(operation.name)>(context)\
##endif
##endfor
);

##endif
    } else \
##endfor
{
        NGREST_THROW_ASSERT("No operation " + operation->name + " found in service $(service.name)");
    }
}

const ::ngrest::ServiceDescription* $(service.name)Wrapper::getDescription() const
{
    static ::ngrest::ServiceDescription description = {
        "$(.nsName.!dot)", // name
        "$(.options.*location)", // location
        R"($(.description))", // description
        R"($(.details))", // details
        {
##var isComma 0
##foreach $(.operations)
##ifeq($($isComma),0)
##var isComma 1
##else
,
##endif
            {
                "$(.name)",             // name
##ifeq($(.options.*location)-$(.options.*method||"GET"),-GET)
##var loc
##ifneq($(operation.params.$count),0)
### generate location for get query
##var loc $(.name)?
##var isAmp 0
##foreach $(operation.params)
##ifneq($(param.dataType.name),Callback||MessageContext)
##ifeq($($isAmp),0)
##var isAmp 1
##else
##var loc $($loc)&
##endif
##var loc $($loc)$(param.name)={$(param.name)}
##endif
##endfor
##endif
                "$($loc)", // location
##else
                "$(.options.*location)", // location
##endif
                static_cast<int>(::ngrest::HttpMethod::$(.options.*method||"GET")),
                "$(.options.*method||"GET")",
                $(.isAsynch||"false"),
                R"($(.description))", // description
                R"($(.details))", // details
                {
##var isCommaParam 0
##foreach $(.params)
##ifneq($(param.dataType.name),Callback||MessageContext)
##ifeq($($isCommaParam),0)
##var isCommaParam 1
##else
,
##endif
                    {"$(.name)", ::ngrest::ParameterDescription::Type::\
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##context $(.dataType.templateParams.templateParam1)
##include <common/jsonType.h>
##endcontext
, true\
##else
##context $(.dataType)
##include <common/jsonType.h>
##endcontext
, false\
##endif
}\
##endif
##endfor // params

                },
                ::ngrest::ParameterDescription::Type::\
##ifeq($(.return.type)-$(.return.name),template-Nullable)
##context $(.return.templateParams.templateParam1)
##include <common/jsonType.h>
##endcontext
, true\
##else
##context $(.return)
##include <common/jsonType.h>
##endcontext
, false\
##endif

            }\
##endfor // operations

        }
    };

    return &description;
}


##endfor
##endif // ##ifneq($(interface.services.$count),0)
$($lastNsEnd)
